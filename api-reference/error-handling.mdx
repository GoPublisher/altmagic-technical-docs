---
title: 'Error Handling'
description: 'Learn how to handle errors and implement proper error handling in your Alt Magic API integrations'
---

# Error Handling

Proper error handling is essential for building robust applications with the Alt Magic API. This guide covers all possible error responses and best practices for handling them gracefully.

## HTTP Status Codes

The Alt Magic API uses standard HTTP status codes to indicate the success or failure of requests.

### Success Responses

| Status | Description |
|--------|-------------|
| **200 OK** | Request successful, alt text generated |
| **201 Created** | Resource created successfully |

### Client Error Responses

| Status | Description |
|--------|-------------|
| **400 Bad Request** | Invalid request parameters |
| **401 Unauthorized** | Authentication required or failed |
| **403 Forbidden** | Insufficient permissions or no credits |
| **404 Not Found** | User or resource not found |
| **429 Too Many Requests** | Rate limit exceeded |

### Server Error Responses

| Status | Description |
|--------|-------------|
| **500 Internal Server Error** | Server-side error occurred |
| **502 Bad Gateway** | Upstream service unavailable |
| **503 Service Unavailable** | Service temporarily unavailable |

## Error Response Format

All error responses follow a consistent format:

```json
{
  "success": false,
  "error": "error_type",
  "message": "Human-readable error message",
  "details": "Additional error details (optional)",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_1234567890abcdef"
}
```

### Error Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `success` | boolean | Always `false` for error responses |
| `error` | string | Machine-readable error identifier |
| `message` | string | Human-readable error description |
| `details` | string | Additional context (optional) |
| `timestamp` | string | ISO 8601 timestamp of the error |
| `request_id` | string | Unique identifier for debugging |

## Common Error Types

### 1. Authentication Errors

#### 401 Unauthorized

```json
{
  "success": false,
  "error": "authentication_required",
  "message": "Valid API key or session required",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_1234567890abcdef"
}
```

**Causes:**
- Missing API key header
- Invalid or expired API key
- Expired session token

**Solutions:**
- Include valid `x-api-key` header
- Generate new API key
- Re-authenticate user session

#### 403 Forbidden

```json
{
  "success": false,
  "error": "insufficient_credits",
  "message": "No credits remaining.",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_1234567890abcdef"
}
```

**Causes:**
- User has no remaining credits
- API key lacks required permissions
- Account suspended

**Solutions:**
- Purchase more credits
- Check API key permissions
- Contact support for account issues

### 2. Validation Errors

#### 400 Bad Request

```json
{
  "success": false,
  "error": "validation_error",
  "message": "Invalid request parameters",
  "details": "image_url must be a valid URL, user_id is required",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_1234567890abcdef"
}
```

**Common Validation Issues:**
- Missing required fields
- Invalid URL format
- Invalid email format
- Unsupported language codes

**Solutions:**
- Review required parameters
- Validate URL format before sending
- Check email format
- Use supported language codes

### 3. Resource Errors

#### 404 Not Found

```json
{
  "success": false,
  "error": "user_not_found",
  "message": "User not found.",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_1234567890abcdef"
}
```

**Causes:**
- User ID doesn't exist
- User account deleted
- Invalid user identifier

**Solutions:**
- Verify user ID is correct
- Check if user account exists
- Use valid email address

### 4. Rate Limiting Errors

#### 429 Too Many Requests

```json
{
  "success": false,
  "error": "rate_limit_exceeded",
  "message": "Too many requests from this User, please try again later.",
  "retry_after": 60,
  "limit": 100,
  "reset_time": "2024-01-15T10:30:00Z",
  "request_id": "req_1234567890abcdef"
}
```

**Causes:**
- Exceeded rate limit (100 req/min for Standard plan)
- Burst requests in short time

**Solutions:**
- Implement exponential backoff
- Queue requests
- Wait for rate limit reset

### 5. Server Errors

#### 500 Internal Server Error

```json
{
  "success": false,
  "error": "internal_server_error",
  "message": "Internal server error",
  "details": "AI service temporarily unavailable",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_1234567890abcdef"
}
```

**Causes:**
- AI service unavailable
- Database connection issues
- Unexpected server errors

**Solutions:**
- Retry with exponential backoff
- Check service status
- Contact support if persistent

## Implementing Error Handling

### 1. JavaScript/Node.js

```javascript
class AltMagicAPI {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.altmagic.pro';
  }

  async generateAltText(data) {
    try {
      const response = await fetch(`${this.baseUrl}/api-alt-text`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey
        },
        body: JSON.stringify(data)
      });

      const result = await response.json();

      if (!response.ok) {
        throw new AltMagicError(result, response.status);
      }

      return result;
    } catch (error) {
      if (error instanceof AltMagicError) {
        throw error;
      }
      throw new AltMagicError({
        success: false,
        error: 'network_error',
        message: 'Network request failed',
        details: error.message
      }, 0);
    }
  }
}

class AltMagicError extends Error {
  constructor(errorData, statusCode) {
    super(errorData.message);
    this.name = 'AltMagicError';
    this.errorType = errorData.error;
    this.statusCode = statusCode;
    this.requestId = errorData.request_id;
    this.timestamp = errorData.timestamp;
    this.details = errorData.details;
  }

  isRetryable() {
    return this.statusCode >= 500 || this.statusCode === 429;
  }

  getRetryDelay() {
    if (this.statusCode === 429) {
      return this.retry_after || 60;
    }
    return Math.pow(2, Math.min(this.retryCount || 0, 5)) * 1000;
  }
}

// Usage with retry logic
async function generateAltTextWithRetry(data, maxRetries = 3) {
  const api = new AltMagicAPI(API_KEY);
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await api.generateAltText(data);
    } catch (error) {
      lastError = error;
      
      if (!error.isRetryable() || attempt === maxRetries) {
        throw error;
      }

      const delay = error.getRetryDelay();
      console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### 2. Python

```python
import requests
import time
from typing import Dict, Any, Optional

class AltMagicError(Exception):
    def __init__(self, error_data: Dict[str, Any], status_code: int):
        super().__init__(error_data.get('message', 'Unknown error'))
        self.error_type = error_data.get('error')
        self.status_code = status_code
        self.request_id = error_data.get('request_id')
        self.timestamp = error_data.get('timestamp')
        self.details = error_data.get('details')
    
    def is_retryable(self) -> bool:
        return self.status_code >= 500 or self.status_code == 429
    
    def get_retry_delay(self) -> int:
        if self.status_code == 429:
            return getattr(self, 'retry_after', 60)
        return min(2 ** (getattr(self, 'retry_count', 0)), 300)

class AltMagicAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = 'https://api.altmagic.pro'
    
    def generate_alt_text(self, data: Dict[str, Any]) -> Dict[str, Any]:
        try:
            response = requests.post(
                f'{self.base_url}/api-alt-text',
                headers={
                    'Content-Type': 'application/json',
                    'x-api-key': self.api_key
                },
                json=data
            )
            
            result = response.json()
            
            if not response.ok:
                raise AltMagicError(result, response.status_code)
            
            return result
            
        except requests.RequestException as e:
            raise AltMagicError({
                'success': False,
                'error': 'network_error',
                'message': 'Network request failed',
                'details': str(e)
            }, 0)

def generate_alt_text_with_retry(data: Dict[str, Any], max_retries: int = 3) -> Dict[str, Any]:
    api = AltMagicAPI(API_KEY)
    last_error = None
    
    for attempt in range(1, max_retries + 1):
        try:
            return api.generate_alt_text(data)
        except AltMagicError as error:
            last_error = error
            
            if not error.is_retryable() or attempt == max_retries:
                raise error
            
            delay = error.get_retry_delay()
            print(f"Attempt {attempt} failed, retrying in {delay}s...")
            time.sleep(delay)
    
    raise last_error
```

### 3. Error Handling Best Practices

#### Always Check Response Status

```javascript
const response = await fetch(url, options);
if (!response.ok) {
  const errorData = await response.json();
  throw new Error(`API Error: ${errorData.message}`);
}
```

#### Implement Proper Retry Logic

```javascript
async function retryWithBackoff(fn, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries || !isRetryableError(error)) {
        throw error;
      }
      
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

#### Log Errors for Debugging

```javascript
try {
  const result = await api.generateAltText(data);
  return result;
} catch (error) {
  console.error('Alt Magic API Error:', {
    error: error.errorType,
    message: error.message,
    requestId: error.requestId,
    timestamp: error.timestamp,
    details: error.details
  });
  throw error;
}
```

## Error Recovery Strategies

### 1. Graceful Degradation

```javascript
async function generateAltTextWithFallback(imageUrl) {
  try {
    const result = await api.generateAltText({ image_url: imageUrl });
    return result.altText;
  } catch (error) {
    if (error.errorType === 'insufficient_credits') {
      // Fallback to basic alt text
      return `Image: ${imageUrl.split('/').pop()}`;
    }
    throw error;
  }
}
```

### 2. Circuit Breaker Pattern

```javascript
class CircuitBreaker {
  constructor(failureThreshold = 5, timeout = 60000) {
    this.failureThreshold = failureThreshold;
    this.timeout = timeout;
    this.failures = 0;
    this.lastFailureTime = 0;
    this.state = 'CLOSED';
  }

  async call(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();
    
    if (this.failures >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}
```

## Monitoring and Alerting

### 1. Error Tracking

```javascript
class ErrorTracker {
  constructor() {
    this.errors = new Map();
  }

  trackError(error) {
    const key = `${error.errorType}:${error.statusCode}`;
    const count = this.errors.get(key) || 0;
    this.errors.set(key, count + 1);
    
    // Send to monitoring service
    this.sendToMonitoring(error);
  }

  sendToMonitoring(error) {
    // Send to your monitoring service (e.g., Sentry, LogRocket)
    console.log('Error tracked:', {
      type: error.errorType,
      status: error.statusCode,
      requestId: error.requestId,
      timestamp: error.timestamp
    });
  }
}
```

### 2. Health Checks

```javascript
async function checkAPIService() {
  try {
    const response = await fetch('https://api.altmagic.pro/health');
    const health = await response.json();
    
    if (health.status === 'healthy') {
      console.log('API service is healthy');
      return true;
    } else {
      console.warn('API service degraded:', health.status);
      return false;
    }
  } catch (error) {
    console.error('API service unavailable:', error.message);
    return false;
  }
}
```

## Getting Help

### 1. Debugging Information

When contacting support, always include:
- **Request ID** from error response
- **Timestamp** of the error
- **Full error response** body
- **Request parameters** (without sensitive data)
- **Steps to reproduce** the issue

### 2. Support Channels

- **Email**: support@altmagic.com
- **Documentation**: [docs.altmagic.com](https://docs.altmagic.com)
- **Status Page**: [status.altmagic.com](https://status.altmagic.com)

### 3. Common Solutions

| Error | Quick Fix |
|-------|-----------|
| **401 Unauthorized** | Check API key validity |
| **403 Forbidden** | Verify credits and permissions |
| **429 Rate Limited** | Implement retry with backoff |
| **500 Server Error** | Retry after delay |
| **Validation Error** | Review request parameters |
